---

---

<div id="drag-drop-calendar" class="card">
  <div class="flex justify-between items-center mb-6">
    <h2 class="text-xl font-semibold">Task Calendar</h2>
    <div class="flex gap-4">
      <button id="prev-week" class="btn btn-secondary btn-sm">← Previous</button
      >
      <button id="next-week" class="btn btn-secondary btn-sm">Next →</button>
    </div>
  </div>

  <div id="calendar-container">
    <!-- Day headers -->
    <div class="calendar-headers">
      <div class="calendar-header-day">Sunday</div>
      <div class="calendar-header-day">Monday</div>
      <div class="calendar-header-day">Tuesday</div>
      <div class="calendar-header-day">Wednesday</div>
      <div class="calendar-header-day">Thursday</div>
      <div class="calendar-header-day">Friday</div>
      <div class="calendar-header-day">Saturday</div>
    </div>

    <!-- Calendar grid -->
    <div id="calendar-grid">
      <!-- Calendar days will be populated by JavaScript -->
    </div>
  </div>
</div>

<script>
  // Lighten the shade of the color
  function hexTo50Shade(hexColor) {
    // Remove # if present
    const hex = hexColor.replace('#', '');

    // Parse RGB values
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);

    // Mix with white (roughly 8% original color, 92% white)
    const mixRatio = 0.08;
    const newR = Math.round(r * mixRatio + 255 * (1 - mixRatio));
    const newG = Math.round(g * mixRatio + 255 * (1 - mixRatio));
    const newB = Math.round(b * mixRatio + 255 * (1 - mixRatio));

    // Convert back to hex
    const toHex = (val) => val.toString(16).padStart(2, '0');
    return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
  }

  class DragDropCalendar {
    constructor() {
      this.currentWeekStart = this.getStartOfWeek(new Date());
      this.todos = [];
      this.init();
    }

    init() {
      this.renderCalendar();
      this.loadTodos();
      this.setupEventListeners();
    }

    getStartOfWeek(date) {
      const d = new Date(date);
      const day = d.getDay();
      const diff = d.getDate() - day;
      return new Date(d.setDate(diff));
    }

    renderCalendar() {
      const grid = document.getElementById('calendar-grid');
      grid.innerHTML = '';

      // Render 21 days (3 weeks)
      for (let i = 0; i < 21; i++) {
        const date = new Date(this.currentWeekStart);
        date.setDate(date.getDate() + i);

        const dayDiv = document.createElement('div');
        dayDiv.className = 'calendar-day';
        // Use local date methods to avoid timezone shifts
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        dayDiv.dataset.date = `${year}-${month}-${day}`;

        // Check if today
        const today = new Date();
        if (date.toDateString() === today.toDateString()) {
          dayDiv.classList.add('today');
        }

        const dateHeader = document.createElement('div');
        dateHeader.className = 'calendar-date';
        dateHeader.textContent = `${date.getMonth() + 1}/${date.getDate()}`;
        dayDiv.appendChild(dateHeader);

        const tasksContainer = document.createElement('div');
        tasksContainer.className = 'tasks-container';
        dayDiv.appendChild(tasksContainer);

        // Add drop zone functionality
        this.setupDropZone(dayDiv);

        grid.appendChild(dayDiv);
      }
    }

    setupDropZone(dayDiv) {
      dayDiv.addEventListener('dragover', (e) => {
        e.preventDefault();
        dayDiv.classList.add('drop-zone');
      });

      dayDiv.addEventListener('dragleave', (e) => {
        if (!dayDiv.contains(e.relatedTarget)) {
          dayDiv.classList.remove('drop-zone');
        }
      });

      dayDiv.addEventListener('drop', (e) => {
        e.preventDefault();
        dayDiv.classList.remove('drop-zone');

        const taskId = e.dataTransfer.getData('text/plain');
        const newDate = dayDiv.dataset.date;
        this.updateTaskDate(taskId, newDate);
      });
    }

    async loadTodos() {
      try {
        const response = await fetch('/api/todos?status=pending');
        if (response.ok) {
          const data = await response.json();
          this.todos = data.tasks || [];
          this.renderTodos();
        }
      } catch (error) {
        console.error('Failed to load todos:', error);
      }
    }

    renderTodos() {
      // Clear existing tasks
      document.querySelectorAll('.tasks-container').forEach((container) => {
        container.innerHTML = '';
      });

      // Group todos by date
      const todosByDate = {};

      this.todos.forEach((todo) => {
        let targetDate = null;

        if (todo.due_date) {
          targetDate = todo.due_date.split('T')[0];
        }

        if (targetDate) {
          if (!todosByDate[targetDate]) {
            todosByDate[targetDate] = [];
          }
          todosByDate[targetDate].push(todo);
        }
      });

      // Render todos and calculate totals
      Object.entries(todosByDate).forEach(([date, todos]) => {
        const dayDiv = document.querySelector(`[data-date="${date}"]`);
        if (dayDiv) {
          const tasksContainer = dayDiv.querySelector('.tasks-container');

          todos.forEach((todo) => {
            const taskElement = this.createTaskElement(todo);
            tasksContainer.appendChild(taskElement);
          });
        }
      });
    }

    createTaskElement(todo) {
      const taskDiv = document.createElement('div');
      taskDiv.className = `calendar-task ${todo.priority}-priority`;
      taskDiv.draggable = true;
      taskDiv.dataset.todoId = todo.id;

      const projectColor = todo.project_color || '#6b7280';
      taskDiv.style['background-color'] = hexTo50Shade(projectColor);
      taskDiv.style['border-left'] = '4px solid ' + projectColor;

      // Use textContent to prevent XSS - never use innerHTML with user data
      const titleDiv = document.createElement('div');
      titleDiv.className = 'task-title';
      titleDiv.textContent = todo.title;
      taskDiv.appendChild(titleDiv);

      taskDiv.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', todo.id);
        taskDiv.classList.add('dragging');
      });

      taskDiv.addEventListener('dragend', () => {
        taskDiv.classList.remove('dragging');
      });

      // Add double-click to edit functionality
      taskDiv.addEventListener('dblclick', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.editTodo(todo.id);
      });

      return taskDiv;
    }

    async editTodo(todoId) {
      try {
        const response = await fetch(`/api/todos/${todoId}`);
        if (response.ok) {
          const todo = await response.json();
          // Use the global editModal function from TodoModal
          if (window.openEditModal) {
            window.openEditModal(todo);
          } else {
            console.error('Edit modal function not available');
          }
        } else if (response.status === 401) {
          window.location.href = '/login';
        } else {
          alert('Failed to load todo for editing');
        }
      } catch (error) {
        alert('Error: ' + error.message);
      }
    }

    async updateTaskDate(taskId, newDate) {
      try {
        const response = await fetch(`/api/todos/${taskId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            due_date: newDate,
          }),
        });

        if (response.ok) {
          // Update the todo in our local array
          const todo = this.todos.find((t) => t.id == taskId);
          if (todo) {
            todo.due_date = newDate;
          }

          // Trigger update event for other components
          window.dispatchEvent(new CustomEvent('todoUpdated'));
        } else {
          console.error('Failed to update task date');
        }
      } catch (error) {
        console.error('Error updating task date:', error);
      }
    }

    setupEventListeners() {
      document.getElementById('prev-week').addEventListener('click', () => {
        this.currentWeekStart.setDate(this.currentWeekStart.getDate() - 7);
        this.renderCalendar();
        this.renderTodos();
      });

      document.getElementById('next-week').addEventListener('click', () => {
        this.currentWeekStart.setDate(this.currentWeekStart.getDate() + 7);
        this.renderCalendar();
        this.renderTodos();
      });

      // Listen for todo updates from other components
      window.addEventListener('todoAdded', () => {
        this.loadTodos();
      });

      window.addEventListener('todoUpdated', () => {
        this.loadTodos();
      });
    }
  }

  // Initialize calendar when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('drag-drop-calendar')) {
      new DragDropCalendar();
    }
  });
</script>
